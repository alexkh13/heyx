<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Vibe Coder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Add CodeMirror CSS and JS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/jsx/jsx.min.js"></script>
    <!-- Import modern fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Pacifico&display=swap" rel="stylesheet">
    <style>
      :root {
        --vibe-gradient: linear-gradient(90deg, #a1c4fd 0%, #c2e9fb 100%);
        --vibe-glass: rgba(255,255,255,0.7);
        --vibe-glass-dark: rgba(23,25,35,0.7);
        --vibe-accent: #fbbf24;
        --vibe-accent2: #38bdf8;
        --vibe-accent3: #a3e635;
        --vibe-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        --vibe-radius: 18px;
        --vibe-header-height: 72px;
        --vibe-sidebar-width: 260px;
        --vibe-fab-size: 56px;
        --font-logo: 'Pacifico', cursive;
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-selected: #e2e8f0;
        --bg-hover: #edf2f7;
        --bg-header: #ffffff;
        --bg-dialog: rgba(0, 0, 0, 0.5);
        --bg-dialog-content: #ffffff;
        --text-primary: #2d3748;
        --text-secondary: #4a5568;
        --text-muted: #718096;
        --border-color: #eaeaea;
        --drawer-bg: #ffffff;
        --border-accent: #4299e1;
        --border-input: #cbd5e0;
        --button-primary: #4299e1;
        --button-primary-hover: #3182ce;
        --button-secondary: #e2e8f0;
        --button-secondary-hover: #cbd5e0;
        --button-secondary-text: #4a5568;
        --button-text: #ffffff;
        --button-disabled: #a0aec0;
        --toolbar-border: #eaeaea;
        --ai-assistant-color: #805ad5;
        --ai-assistant-bg: #faf5ff;
        --ai-assistant-bg-hover: #f3ebff;
        --font-size-xs: 12px;
        --font-size-sm: 14px;
        --font-size-md: 16px;
        --font-size-lg: 18px;
        --font-size-xl: 20px;
        --font-size-2xl: 24px;
        --space-1: 4px;
        --space-2: 8px;
        --space-3: 12px;
        --space-4: 16px;
        --space-5: 20px;
        --space-6: 24px;
        --space-8: 32px;
        --space-10: 40px;
        --space-12: 48px;
        --space-16: 64px;
        --radius-sm: 4px;
        --radius-md: 6px;
        --radius-lg: 8px;
        --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        --font-mono: 'JetBrains Mono', 'Fira Code', 'Roboto Mono', monospace;
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg-primary: #171923;
          --bg-secondary: #1a202c;
          --bg-selected: #2d3748;
          --bg-hover: #2d3748;
          --bg-header: #171923;
          --bg-dialog: rgba(0, 0, 0, 0.8);
          --bg-dialog-content: #1a202c;
          --text-primary: #f7fafc;
          --text-secondary: #a0aec0;
          --text-muted: #718096;
          --border-color: #2d3748;
          --border-input: #4a5568;
          --drawer-bg: #1a202c;
          --border-accent: #63b3ed;
          --button-primary: #3182ce;
          --button-primary-hover: #2b6cb0;
          --button-secondary: #2d3748;
          --button-secondary-hover: #4a5568;
          --button-secondary-text: #e2e8f0;
          --button-text: #f7fafc;
          --button-disabled: #4a5568;
          --toolbar-border: #2d3748;
          --ai-assistant-color: #b794f4;
          --ai-assistant-bg: #2d2447;
          --ai-assistant-bg-hover: #352b54;
          --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
          --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
          --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
          --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
        }

        .CodeMirror {
          background-color: #282a36 !important;
        }
      }

      * {
        box-sizing: border-box;
      }

      html,
      body,
      #root {
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        background: var(--vibe-gradient);
        color: var(--text-primary);
        font-family: var(--font-sans);
        font-size: var(--font-size-md);
        line-height: 1.5;
      }

      body, html {
        position: relative;
        min-height: 100vh;
      }

      body::before {
        content: "";
        position: fixed;
        z-index: 0;
        top: 0; left: 0; right: 0; bottom: 0;
        background: radial-gradient(circle at 80% 20%, #fbbf24 0%, transparent 60%),
                    radial-gradient(circle at 20% 80%, #38bdf8 0%, transparent 60%);
        opacity: 0.15;
        pointer-events: none;
        animation: vibe-bg-move 12s linear infinite alternate;
      }

      @keyframes vibe-bg-move {
        0% { background-position: 80% 20%, 20% 80%; }
        100% { background-position: 60% 40%, 40% 60%; }
      }

      .app-container {
        display: flex;
        height: calc(100vh - var(--space-12));
      }

      .header {
        height: var(--vibe-header-height);
        background: var(--vibe-glass);
        backdrop-filter: blur(16px);
        border-bottom: none;
        box-shadow: var(--vibe-shadow);
        border-radius: 0 0 var(--vibe-radius) var(--vibe-radius);
        display: flex;
        align-items: center;
        padding: 0 40px;
        position: relative;
        z-index: 10;
        justify-content: space-between;
        margin: 16px 16px 0 16px;
      }

      .header-logo {
        display: flex;
        align-items: center;
        font-family: var(--font-logo);
        font-size: 2.2rem;
        color: var(--vibe-accent2);
        letter-spacing: 2px;
        gap: 18px;
        user-select: none;
      }

      .header-logo span {
        color: var(--vibe-accent);
        font-size: 2.4rem;
        margin-left: 4px;
      }

      .vibe-meter {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--vibe-accent3);
        background: rgba(255,255,255,0.5);
        border-radius: 999px;
        padding: 6px 18px;
        box-shadow: 0 2px 8px 0 rgba(163,230,53,0.12);
        transition: background 0.3s, color 0.3s;
        min-width: 120px;
      }

      .vibe-meter-bar {
        width: 48px;
        height: 12px;
        background: linear-gradient(90deg, #fbbf24 0%, #38bdf8 100%);
        border-radius: 8px;
        overflow: hidden;
        position: relative;
      }

      .vibe-meter-fill {
        position: absolute;
        left: 0; top: 0; bottom: 0;
        background: #a3e635;
        border-radius: 8px;
        transition: width 0.5s cubic-bezier(.4,2,.6,1);
        height: 100%;
      }

      .sidebar {
        width: var(--vibe-sidebar-width);
        background: var(--vibe-glass);
        backdrop-filter: blur(12px);
        border-radius: var(--vibe-radius);
        margin: 24px 0 24px 16px;
        box-shadow: var(--vibe-shadow);
        border: none;
        overflow: visible;
        display: flex;
        flex-direction: column;
        z-index: 2;
      }

      .sidebar-header {
        font-family: var(--font-logo);
        font-size: 1.6rem;
        color: var(--vibe-accent2);
        padding: 28px 0 12px 32px;
        border-bottom: none;
        background: none;
      }

      .challenges-list {
        padding: 0 0 24px 0;
        margin: 0;
        list-style: none;
      }

      .challenge-item {
        border: none;
        margin: 0 18px 12px 18px;
        border-radius: var(--vibe-radius);
        background: rgba(255,255,255,0.5);
        box-shadow: 0 2px 8px 0 rgba(56,189,248,0.08);
        transition: box-shadow 0.2s, background 0.2s;
      }

      .challenge-header {
        padding: 18px 24px;
        border-radius: var(--vibe-radius);
        cursor: pointer;
        display: flex;
        gap: 14px;
        align-items: center;
        background: none;
        transition: background 0.2s;
      }

      .challenge-header.selected, .challenge-header:hover {
        background: linear-gradient(90deg, #c2e9fb 0%, #a1c4fd 100%);
        box-shadow: 0 4px 16px 0 rgba(56,189,248,0.12);
      }

      .challenge-title {
        font-weight: 700;
        font-size: 1.1rem;
        color: #22223b;
        flex: 1;
        letter-spacing: 1px;
      }

      .challenge-checkbox {
        accent-color: var(--vibe-accent3);
        width: 22px;
        height: 22px;
        border-radius: 8px;
        margin-right: 0;
      }

      .challenge-expand {
        color: var(--vibe-accent2);
        transition: transform 0.2s;
      }

      .challenge-expand.open {
        transform: rotate(90deg);
      }

      .challenge-content {
        padding: 0 24px;
        max-height: 0;
        overflow: hidden;
        transition: all 0.3s ease;
        background: none;
      }

      .challenge-content.open {
        padding: 12px 24px 18px 24px;
        max-height: 200px;
        overflow-y: auto;
      }

      .challenge-description {
        font-size: 1rem;
        color: #4a5568;
        margin-bottom: 0;
        line-height: 1.6;
      }

      .main-content {
        flex: 1;
        display: flex;
        position: relative;
        flex-direction: column;
        margin-right: 60px;
        margin-left: 0;
        margin-top: 24px;
        margin-bottom: 24px;
        border-radius: var(--vibe-radius);
        background: rgba(255,255,255,0.6);
        box-shadow: var(--vibe-shadow);
        overflow: hidden;
        z-index: 1;
      }

      .editor-container {
        flex: 1;
        overflow: auto;
        padding: 32px 48px 32px 48px;
        border-radius: var(--vibe-radius);
        background: transparent;
      }

      .sidebar-right {
        background: none;
        border: none;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        padding: 0;
        z-index: 90;
        position: fixed;
        right: 32px;
        top: calc(var(--vibe-header-height) + 32px);
        bottom: 32px;
        pointer-events: none;
      }

      .fab-container {
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: flex-end;
        height: auto;
        padding: 0;
        pointer-events: all;
      }

      .fab-button {
        width: var(--vibe-fab-size);
        height: var(--vibe-fab-size);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #fbbf24 0%, #38bdf8 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 24px 0 rgba(56,189,248,0.18);
        transition: all 0.18s;
        padding: 0;
        font-size: 1.5rem;
        position: relative;
      }

      .fab-button:hover {
        transform: scale(1.08) rotate(-2deg);
        background: linear-gradient(135deg, #38bdf8 0%, #fbbf24 100%);
        box-shadow: 0 8px 32px 0 rgba(251,191,36,0.18);
      }

      .fab-button:active {
        transform: scale(0.96);
      }

      .fab-button svg {
        width: 32px;
        height: 32px;
        margin: 0;
      }

      .fab-run {
        background: linear-gradient(135deg, #a3e635 0%, #38bdf8 100%);
      }

      .fab-preview {
        background: linear-gradient(135deg, #38bdf8 0%, #fbbf24 100%);
      }

      .fab-reset {
        background: linear-gradient(135deg, #f56565 0%, #fbbf24 100%);
      }

      .fab-new-vibe {
        background: linear-gradient(135deg, #fbbf24 0%, #a3e635 100%);
        position: fixed;
        bottom: 40px;
        right: 40px;
        z-index: 1001;
        box-shadow: 0 8px 32px 0 rgba(251,191,36,0.22);
        font-size: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .fab-new-vibe:hover {
        background: linear-gradient(135deg, #a3e635 0%, #fbbf24 100%);
      }

      /* Dialog styles */
      .dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--bg-dialog);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .dialog-content {
        background: var(--bg-dialog-content);
        border-radius: var(--radius-lg);
        width: 90%;
        max-width: 500px;
        padding: var(--space-6);
        box-shadow: var(--shadow-xl);
      }

      .dialog-header {
        margin-bottom: var(--space-4);
      }

      .dialog-title {
        font-size: var(--font-size-xl);
        font-weight: 600;
        margin: 0;
        margin-bottom: var(--space-2);
      }

      .dialog-description {
        color: var(--text-secondary);
        margin: 0;
        line-height: 1.5;
      }

      .dialog-form {
        margin-top: var(--space-6);
      }

      .dialog-form-group {
        margin-bottom: var(--space-4);
      }

      .dialog-label {
        display: block;
        margin-bottom: var(--space-2);
        font-weight: 500;
      }

      .dialog-input {
        width: 100%;
        padding: var(--space-3);
        border: 1px solid var(--border-input);
        border-radius: var(--radius-md);
        font-family: var(--font-sans);
        background-color: var(--bg-primary);
        color: var(--text-primary);
      }

      .dialog-input:focus {
        outline: none;
        border-color: var(--border-accent);
        box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2);
      }

      .dialog-footer {
        display: flex;
        justify-content: flex-end;
        gap: var(--space-4);
        margin-top: var(--space-6);
      }

      .provider-option {
        display: flex;
        align-items: center;
        gap: var(--space-3);
        padding: var(--space-3);
        border: 1px solid var(--border-input);
        border-radius: var(--radius-md);
        margin-bottom: var(--space-3);
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .provider-option:hover {
        border-color: var(--border-accent);
        background-color: var(--bg-hover);
      }

      .provider-option.selected {
        border-color: var(--border-accent);
        background-color: var(--bg-selected);
      }

      .provider-option-input {
        width: 18px;
        height: 18px;
      }

      .provider-option-label {
        font-weight: 500;
      }

      /* Scrollbar styling for modern browsers */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: var(--radius-sm);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--text-secondary);
        opacity: 0.5;
        border-radius: var(--radius-sm);
        border: 2px solid var(--bg-secondary);
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--border-accent);
      }

      /* SVG Icons */
      .icon-vibe {
        width: 20px;
        height: 20px;
        margin-right: 8px;
      }

      .icon-submit {
        width: 16px;
        height: 16px;
      }

      .icon-preview {
        width: 16px;
        height: 16px;
      }

      .icon-chevron {
        width: 16px;
        height: 16px;
      }

      .icon-ai {
        width: 18px;
        height: 18px;
      }

      .icon-settings {
        width: 14px;
        height: 14px;
      }

      .icon-spinner {
        animation: spin 1s linear infinite;
        width: 16px;
        height: 16px;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://ga.jspm.io/npm:react@18.3.1/index.js",
          "react-dom": "https://ga.jspm.io/npm:react-dom@18.3.1/index.js"
        },
        "scopes": {
          "https://ga.jspm.io/": {
            "scheduler": "https://ga.jspm.io/npm:scheduler@0.23.2/index.js"
          }
        }
      }
    </script>

    <!-- ES Module Shims: Import maps polyfill for older browsers -->
    <script
      async
      src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"
      crossorigin="anonymous"
    ></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="react" data-type="module">
      import React, { useState, useCallback, useEffect, useRef, useMemo, createContext, useContext } from "react";
      import ReactDOM from "react-dom";

      // =========== APP CONSTANTS AND CONTEXT ===========

      // Theme Context
      const ThemeContext = createContext({
        isDarkMode: false,
      });

      function ThemeProvider({ children }) {
        const [isDarkMode, setIsDarkMode] = useState(() => 
          window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
        );
        
        useEffect(() => {
          const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
          const handleDarkModeChange = (e) => setIsDarkMode(e.matches);
          
          darkModeMediaQuery.addEventListener('change', handleDarkModeChange);
          return () => darkModeMediaQuery.removeEventListener('change', handleDarkModeChange);
        }, []);
        
        return (
          <ThemeContext.Provider value={{ isDarkMode }}>
            {children}
          </ThemeContext.Provider>
        );
      }

      const useTheme = () => useContext(ThemeContext);

      // Challenge Context
      const ChallengeContext = createContext({
        challenges: [],
        currentChallengeId: '',
        challengeCodes: {},
        getChallengeById: () => null,
        getCurrentChallenge: () => null,
        updateChallengeCode: () => {},
        selectChallenge: () => {},
        markChallengeCompleted: () => {}
      });

      function ChallengeProvider({ children, initialChallenges }) {
        const [state, setState] = useState(() => {
          const savedState = JSON.parse(
            localStorage.getItem("codeEditor") || "{}"
          );
          
          // Initialize with starter code for challenges without saved code
          const initial = {};
          initialChallenges.forEach((challenge) => {
            initial[challenge.id] = 
              (savedState.challengeCodes && savedState.challengeCodes[challenge.id]) || 
              challenge.starterCode;
          });
          
          return {
            currentChallengeId: savedState.currentChallengeId || initialChallenges[0].id,
            challenges: savedState.challenges || initialChallenges,
            challengeCodes: initial
          };
        });
        
        // Debounced save to localStorage
        const saveToLocalStorage = useCallback(
          debounce((newState) => {
            localStorage.setItem(
              "codeEditor",
              JSON.stringify(newState)
            );
          }, 1000),
          []
        );
        
        // Save state to localStorage
        useEffect(() => {
          saveToLocalStorage(state);
        }, [state, saveToLocalStorage]);

        // Context value with state and methods
        const value = useMemo(() => ({
          ...state,
          getChallengeById: (id) => state.challenges.find(c => c.id === id),
          getCurrentChallenge: () => state.challenges.find(c => c.id === state.currentChallengeId),
          updateChallengeCode: (challengeId, code) => {
            setState(prev => ({
              ...prev,
              challengeCodes: {
                ...prev.challengeCodes,
                [challengeId]: code
              }
            }));
          },
          selectChallenge: (challengeId) => {
            setState(prev => ({
              ...prev,
              currentChallengeId: challengeId
            }));
          },
          markChallengeCompleted: (challengeId) => {
            setState(prev => ({
              ...prev,
              challenges: prev.challenges.map(c => 
                c.id === challengeId ? { ...c, completed: true } : c
              )
            }));
          }
        }), [state]);

        return (
          <ChallengeContext.Provider value={value}>
            {children}
          </ChallengeContext.Provider>
        );
      }

      const useChallenges = () => useContext(ChallengeContext);

      // AI Provider Context
      const AI_PROVIDERS = {
        OPENAI: {
          name: 'OpenAI',
          endpoint: 'https://api.openai.com/v1/chat/completions',
          apiKeyName: 'OPENAI_API_KEY',
          defaultModel: 'gpt-3.5-turbo',
          models: [
            { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' },
            { id: 'gpt-4', name: 'GPT-4' },
            { id: 'gpt-4-turbo', name: 'GPT-4 Turbo' }
          ],
          formatRequest: (prompt, code, model) => ({
            model: model || 'gpt-3.5-turbo',
            messages: [
              {
                role: 'system',
                content: `You are a helpful AI assistant that helps write and improve code for a browser-based React application. 
                    
IMPORTANT ENVIRONMENT CONSTRAINTS:
- This is a pure browser environment using ES modules (no Node.js, no build steps)
- Code uses React 18 with Babel standalone for JSX transpilation
- All imports must use ES module syntax (import React from 'react')
- No npm packages are available except those explicitly imported via CDN/import maps
- Available libraries: React, ReactDOM, CodeMirror
- No server-side code, database access, or file system operations
- All code must run entirely in the browser

AVAILABLE COMPONENTS:
- Header: Main application header with logo and action buttons
- Sidebar: Shows list of coding challenges
- ChallengeItem: Individual challenge in the sidebar with accordion expansion
- CodeEditor: CodeMirror-based editor component
- Preview: Live preview of code execution 
- AIAssistant: AI code generation assistant (this component)
- APIKeyDialog: Dialog for API configuration

Respond with only the code changes requested. No explanations, just the code.`
              },
              {
                role: 'user',
                content: `I have the following code:\n\n\`\`\`\n${code}\n\`\`\`\n\nRequest: ${prompt}`
              }
            ],
            temperature: 0.7,
            max_tokens: 2048
          }),
          customHeaders: (apiKey) => ({
            'Authorization': `Bearer ${apiKey}`
          }),
          extractResponse: (data) => data.choices[0].message.content
        },
        ANTHROPIC: {
          name: 'Anthropic',
          endpoint: 'https://api.anthropic.com/v1/messages',
          apiKeyName: 'ANTHROPIC_API_KEY',
          defaultModel: 'claude-3-haiku-20240307',
          models: [
            { id: 'claude-3-haiku-20240307', name: 'Claude 3 Haiku' },
            { id: 'claude-3-sonnet-20240229', name: 'Claude 3 Sonnet' },
            { id: 'claude-3-opus-20240229', name: 'Claude 3 Opus' }
          ],
          formatRequest: (prompt, code, model) => ({
            model: model || 'claude-3-haiku-20240307',
            max_tokens: 2048,
            messages: [
              {
                role: 'system',
                content: `You are a helpful AI assistant that helps write and improve code for a browser-based React application.
                    
IMPORTANT ENVIRONMENT CONSTRAINTS:
- This is a pure browser environment using ES modules (no Node.js, no build steps)
- Code uses React 18 with Babel standalone for JSX transpilation
- All imports must use ES module syntax (import React from 'react')
- No npm packages are available except those explicitly imported via CDN/import maps
- Available libraries: React, ReactDOM, CodeMirror
- No server-side code, database access, or file system operations
- All code must run entirely in the browser

AVAILABLE COMPONENTS:
- Header: Main application header with logo and action buttons
- Sidebar: Shows list of coding challenges
- ChallengeItem: Individual challenge in the sidebar with accordion expansion
- CodeEditor: CodeMirror-based editor component
- Preview: Live preview of code execution 
- AIAssistant: AI code generation assistant (this component)
- APIKeyDialog: Dialog for API configuration`
              },
              {
                role: 'user',
                content: `I have the following code:\n\n\`\`\`\n${code}\n\`\`\`\n\nRequest: ${prompt}\n\nRespond with only the code changes requested. No explanations, just the code.`
              }
            ]
          }),
          customHeaders: (apiKey) => ({
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01'
          }),
          extractResponse: (data) => data.content[0].text
        }
      };

      const AIContext = createContext({
        provider: 'OPENAI',
        apiKey: '',
        model: '',
        isConfigured: false,
        setApiConfig: () => {},
        generateCompletions: async () => {},
      });

      function AIProvider({ children }) {
        const [config, setConfig] = useState(() => {
          const provider = localStorage.getItem('ai_provider') || 'OPENAI';
          const apiKey = localStorage.getItem(AI_PROVIDERS[provider]?.apiKeyName || '');
          const model = localStorage.getItem(`${provider}_MODEL`) || AI_PROVIDERS[provider]?.defaultModel;
          
          return { 
            provider, 
            apiKey, 
            model,
            isProcessing: false,
            status: ''
          };
        });
        
        const { getCurrentChallenge } = useChallenges();
        
        const setApiConfig = useCallback((newConfig) => {
          // Store in localStorage
          localStorage.setItem('ai_provider', newConfig.provider);
          localStorage.setItem(AI_PROVIDERS[newConfig.provider].apiKeyName, newConfig.apiKey);
          localStorage.setItem(`${newConfig.provider}_MODEL`, newConfig.model);
          
          setConfig(prev => ({
            ...prev,
            ...newConfig
          }));
        }, []);
        
        const generateCompletions = useCallback(async (prompt, code, onSuccess) => {
          if (!prompt.trim()) {
            setConfig(prev => ({ ...prev, status: 'Please enter a prompt' }));
            return false;
          }

          if (!config.apiKey) {
            return false;
          }

          setConfig(prev => ({ 
            ...prev, 
            isProcessing: true,
            status: 'Processing your request...'
          }));

          try {
            const provider = AI_PROVIDERS[config.provider];
            
            // Get context about the current challenge
            const currentChallenge = getCurrentChallenge();
            const challengeContext = currentChallenge 
              ? `Current challenge: ${currentChallenge.title} - ${currentChallenge.description}`
              : "";
            
            // Enhance the prompt with context about the current challenge
            const enhancedPrompt = challengeContext 
              ? `${challengeContext}\n\n${prompt}`
              : prompt;
            
            const headers = {
              'Content-Type': 'application/json',
              ...(provider.customHeaders ? provider.customHeaders(config.apiKey) : {})
            };

            const response = await fetch(provider.endpoint, {
              method: 'POST',
              headers,
              body: JSON.stringify(provider.formatRequest(enhancedPrompt, code, config.model))
            });

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error?.message || 'Failed to get response from AI service');
            }

            const data = await response.json();
            const result = provider.extractResponse(data);
            
            // Strip code blocks and unnecessary formatting from result
            let codeResult = result;
            if (result.includes('```')) {
              const codeBlockMatch = result.match(/```(?:jsx?|tsx?|javascript)?\n([\s\S]+?)```/);
              if (codeBlockMatch && codeBlockMatch[1]) {
                codeResult = codeBlockMatch[1];
              }
            }
            
            // Check for browser-incompatible patterns
            const incompatiblePatterns = [
              { pattern: /import\s+.+\s+from\s+['"](?!react|react-dom)([^/][^'"]*)['"];?/g, message: 'Unsupported import from non-CDN source' },
              { pattern: /require\s*\(/g, message: 'require() is not supported in browser environment' },
              { pattern: /fs\.|path\.|process\.env|__dirname|__filename/g, message: 'Node.js APIs are not available in browser' },
              { pattern: /module\.exports|exports\./g, message: 'CommonJS module system not supported' }
            ];
            
            let isValidCode = true;
            let validationMessage = '';
            
            for (const { pattern, message } of incompatiblePatterns) {
              if (pattern.test(codeResult)) {
                isValidCode = false;
                validationMessage = message;
                break;
              }
            }
            
            if (!isValidCode) {
              setConfig(prev => ({
                ...prev,
                status: `Error: ${validationMessage}. The AI generated code that isn't compatible with the browser environment. Try a different prompt.`
              }));
              
              return false;
            } else {
              // Try to parse the code with Babel to ensure it's valid
              try {
                // Only perform this check for complete function/component definitions
                if (codeResult.includes('function') || codeResult.includes('class') || codeResult.includes('=>')) {
                  window.Babel.transform(codeResult, { presets: ['react'] });
                }
                
                // Update the code through callback
                onSuccess(codeResult);
                
                setConfig(prev => ({
                  ...prev,
                  status: 'Code updated successfully'
                }));
                
                return true;
              } catch (syntaxError) {
                setConfig(prev => ({
                  ...prev,
                  status: `Syntax error in generated code: ${syntaxError.message}. Try a different prompt.`
                }));
                
                return false;
              }
            }
          } catch (error) {
            console.error('Error generating completions:', error);
            
            setConfig(prev => ({
              ...prev,
              status: `Error: ${error.message}`
            }));
            
            return false;
          } finally {
            setConfig(prev => ({ 
              ...prev, 
              isProcessing: false 
            }));
          }
        }, [config.apiKey, config.model, config.provider, getCurrentChallenge]);

        const value = useMemo(() => ({
          ...config,
          isConfigured: !!config.apiKey,
          setApiConfig,
          generateCompletions,
          providers: AI_PROVIDERS
        }), [config, setApiConfig, generateCompletions]);

        return (
          <AIContext.Provider value={value}>
            {children}
          </AIContext.Provider>
        );
      }

      const useAI = () => useContext(AIContext);

      // =========== UTILITIES ===========

      // SVG Icons
      const Icons = {
        Vibe: () => (
          <svg className="icon-vibe" fill="none" viewBox="0 0 64 64" stroke="currentColor">
            <circle cx="32" cy="32" r="30" strokeWidth="4" stroke="#38bdf8" fill="#fbbf24"/>
            <ellipse cx="32" cy="40" rx="16" ry="8" fill="#fff" opacity="0.5"/>
            <path d="M24 28c0-4 4-8 8-8s8 4 8 8" stroke="#22223b" strokeWidth="3" strokeLinecap="round"/>
            <circle cx="24" cy="32" r="3" fill="#22223b"/>
            <circle cx="40" cy="32" r="3" fill="#22223b"/>
            <path d="M28 44c2 2 8 2 10 0" stroke="#22223b" strokeWidth="2" strokeLinecap="round"/>
          </svg>
        ),
        NewVibe: () => (
          <svg width="36" height="36" fill="none" viewBox="0 0 36 36" stroke="currentColor">
            <circle cx="18" cy="18" r="16" stroke="#a3e635" strokeWidth="3" fill="#fff" />
            <path d="M18 11v14M11 18h14" stroke="#fbbf24" strokeWidth="3" strokeLinecap="round"/>
          </svg>
        ),
        Run: () => (
          <svg className="icon-submit" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        ),
        Preview: () => (
          <svg className="icon-preview" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
          </svg>
        ),
        HidePreview: () => (
          <svg className="icon-preview" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
          </svg>
        ),
        Check: () => (
          <svg className="icon-submit" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        ),
        ChevronRight: () => (
          <svg className="icon-chevron" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        ),
        AI: () => (
          <svg className="icon-ai" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 3.104v5.714a2.25 2.25 0 01-.659 1.591L5 14.5M9.75 3.104c-.251.023-.501.05-.75.082m.75-.082a24.301 24.301 0 014.5 0m0 0v5.714c0 .597.237 1.17.659 1.591L19.8 15.3M14.25 3.104c.251.023.501.05.75.082M19.8 15.3l-1.57.393A9.065 9.065 0 0112 15a9.065 9.065 0 00-6.23-.693L5 14.5m14.8.8l1.402 1.402c1.232 1.232.65 3.318-1.067 3.611A48.309 48.309 0 0112 21c-2.773 0-5.491-.235-8.135-.687-1.718-.293-2.3-2.379-1.067-3.61L5 14.5" />
          </svg>
        ),
        Reset: () => (
          <svg className="icon-reset" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        ),
        Settings: () => (
          <svg className="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" />
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
        ),
        Spinner: () => (
          <svg className="icon-spinner" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        )
      };

      // Vibe Meter Component
      function VibeMeter({ status }) {
        const [fill, setFill] = React.useState(60);
        React.useEffect(() => {
          if (status === "success") setFill(100);
          else if (status === "fail") setFill(20);
          else setFill(60);
          if (status !== "idle") {
            const t = setTimeout(() => setFill(60), 1200);
            return () => clearTimeout(t);
          }
        }, [status]);
        return (
          <div className="vibe-meter" title="Vibe Meter">
            <span>Vibe Meter</span>
            <div className="vibe-meter-bar">
              <div className="vibe-meter-fill" style={{
                width: fill + "%",
                background: status === "success"
                  ? "linear-gradient(90deg,#a3e635,#38bdf8)"
                  : status === "fail"
                  ? "linear-gradient(90deg,#f56565,#fbbf24)"
                  : "linear-gradient(90deg,#fbbf24,#38bdf8)"
              }} />
            </div>
          </div>
        );
      }

      // Header Component (add VibeMeter)
      function Header({ vibeStatus }) {
        return (
          <div className="header">
            <div className="header-logo">
              <Icons.Vibe />
              Vibe<span>Coder</span>
            </div>
            <VibeMeter status={vibeStatus} />
          </div>
        );
      }

      // Challenge Item Component 
      function ChallengeItem({ challenge, isSelected, onSelect, isExpanded, onToggleExpand }) {
        return (
          <div className="challenge-item">
            <div 
              className={`challenge-header ${isSelected ? 'selected' : ''}`} 
              onClick={() => onSelect(challenge.id)}
            >
              <input
                type="checkbox"
                className="challenge-checkbox"
                checked={challenge.completed}
                readOnly
                onClick={(e) => e.stopPropagation()}
              />
              <div className="challenge-title">{challenge.title}</div>
              <div 
                className={`challenge-expand ${isExpanded ? 'open' : ''}`}
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleExpand(challenge.id);
                }}
              >
                <Icons.ChevronRight />
              </div>
            </div>
            <div className={`challenge-content ${isExpanded ? 'open' : ''}`}>
              <div className="challenge-description">{challenge.description}</div>
            </div>
          </div>
        );
      }

      // Sidebar Component
      function Sidebar() {
        const { challenges, currentChallengeId, selectChallenge } = useChallenges();
        const [expandedId, setExpandedId] = useState(currentChallengeId);
        
        // Automatically expand the selected challenge
        useEffect(() => {
          setExpandedId(currentChallengeId);
        }, [currentChallengeId]);
        
        const handleToggleExpand = (id) => {
          setExpandedId(expandedId === id ? null : id);
        };
        
        return (
          <div className="sidebar">
            <div className="sidebar-header">
              <span>Challenges</span>
            </div>
            <div className="challenges-list">
              {challenges.map((challenge) => (
                <ChallengeItem
                  key={challenge.id}
                  challenge={challenge}
                  isSelected={challenge.id === currentChallengeId}
                  onSelect={selectChallenge}
                  isExpanded={expandedId === challenge.id}
                  onToggleExpand={handleToggleExpand}
                />
              ))}
            </div>
          </div>
        );
      }

      // Preview Component
      function Preview() {
        const { currentChallengeId, challengeCodes } = useChallenges();
        const code = challengeCodes[currentChallengeId] || '';
        const iframeRef = useRef(null);
        const [hasChanges, setHasChanges] = useState(false);
        const [lastRenderedCode, setLastRenderedCode] = useState(code);
        const isDrawerOpen = useRef(false); // Ref to track drawer state

        // Get drawer open state from parent component
        useEffect(() => {
          const drawer = document.querySelector('.preview-drawer');
          if (drawer) {
            const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                if (mutation.attributeName === 'class') {
                  isDrawerOpen.current = drawer.classList.contains('open');
                  // If drawer just opened and there are changes, render preview
                  if (isDrawerOpen.current && hasChanges) {
                    renderPreview();
                  }
                }
              });
            });
            
            observer.observe(drawer, { attributes: true });
            isDrawerOpen.current = drawer.classList.contains('open');
            
            return () => observer.disconnect();
          }
        }, [hasChanges]);

        // Reset lastRenderedCode when challenge changes
        useEffect(() => {
          setLastRenderedCode(""); // Reset on challenge change
          setHasChanges(true);
          
          // Only render immediately if drawer is open
          if (isDrawerOpen.current) {
            renderPreview();
          }
        }, [currentChallengeId]);

        useEffect(() => {
          if (code !== lastRenderedCode) {
            setHasChanges(true);
            
            // Only auto-update if drawer is open
            if (isDrawerOpen.current) {
              renderPreview();
            }
          }
        }, [code, lastRenderedCode]);

        const renderPreview = useCallback(() => {
          const iframe = iframeRef.current;
          if (!iframe) return;

          // Determine if the code contains React/JSX syntax
          const isReactComponent =
            code.includes("function") &&
            code.includes("return") &&
            code.includes("<");

          // make sure to avoid writing <script> directly here
          // use string literal instead, e.g. ${script}
          const script = "script";

          const html = `
            <!DOCTYPE html>
            <html>
              <head>
                <${script} type="importmap">
                  {
                    "imports": {
                      "react": "https://ga.jspm.io/npm:react@18.3.1/index.js",
                      "react-dom": "https://ga.jspm.io/npm:react-dom@18.3.1/index.js"
                    },
                    "scopes": {
                      "https://ga.jspm.io/": {
                        "scheduler": "https://ga.jspm.io/npm:scheduler@0.23.2/index.js"
                      }
                    }
                  }
                </${script}>
                <${script} async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></${script}>
                <${script} src="https://unpkg.com/@babel/standalone/babel.min.js"></${script}>
                <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
                <style>
                  :root {
                    --blue-500: #3182ce;
                    --blue-600: #2b6cb0;
                    --gray-100: #f7fafc;
                    --gray-200: #edf2f7;
                    --gray-700: #4a5568;
                    --gray-900: #1a202c;
                    --red-500: #f56565;
                    --green-500: #48bb78;
                  }
                  
                  * {
                    box-sizing: border-box;
                  }
                  
                  body {
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    padding: 24px;
                    line-height: 1.5;
                    color: var(--gray-900);
                    font-size: 16px;
                    margin: 0;
                  }
                  
                  .dark-mode {
                    background-color: var(--gray-900);
                    color: var(--gray-100);
                  }

                  h1, h2, h3, h4, h5 {
                    margin-top: 0;
                    line-height: 1.2;
                  }
                  
                  button {
                    margin: 0 6px;
                    padding: 6px 12px;
                    background: var(--blue-500);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-family: inherit;
                    font-size: 14px;
                    font-weight: 500;
                  }
                  
                  button:hover {
                    background: var(--blue-600);
                  }
                  
                  pre {
                    background: var(--gray-100);
                    padding: 16px;
                    border-radius: 8px;
                    overflow: auto;
                    font-size: 14px;
                    border: 1px solid var(--gray-200);
                  }
                  
                  .error {
                    color: var(--red-500);
                    padding: 12px;
                    border-radius: 6px;
                    background-color: rgba(245, 101, 101, 0.1);
                    margin: 16px 0;
                  }
                  
                  .success {
                    color: var(--green-500);
                    padding: 12px;
                    border-radius: 6px;
                    background-color: rgba(72, 187, 120, 0.1);
                    margin: 16px 0;
                  }
                  
                  @media (prefers-color-scheme: dark) {
                    body {
                      background-color: var(--gray-900);
                      color: var(--gray-100);
                    }
                    pre {
                      background: rgba(255, 255, 255, 0.1);
                      border-color: rgba(255, 255, 255, 0.2);
                    }
                  }
                </style>
              </head>
              <body>
                <div id="root"></div>
                <${script} type="text/babel" data-presets="react" data-type="module">
                  import React from 'react';
                  import ReactDOM from 'react-dom';

                  ${code}
                  ${
                    isReactComponent
                      ? `
                    // Extract the component name from the code
                    const match = ${JSON.stringify(
                      code
                    )}.match(/function\\s+(\\w+)/);
                    if (match) {
                      const ComponentName = eval(match[1]);
                      ReactDOM.render(React.createElement(ComponentName), document.getElementById('root'));
                    }
                  `
                      : `
                    // For non-React challenges, show the function result
                    const match = ${JSON.stringify(
                      code
                    )}.match(/function\\s+(\\w+)/);
                    if (match) {
                      const funcName = match[1];
                      const func = eval('(' + ${JSON.stringify(code)} + ')');
                      document.getElementById('root').innerHTML = '<h3>Function: ' + funcName + '</h3>' +
                        '<p>Try calling this function in the browser console!</p>' +
                        '<div class="success">✓ Function defined successfully</div>';
                      window[funcName] = func;
                      console.log("✓ Function " + funcName + " is available in the console.");
                    }
                  `
                  }
                </${script}>
              </body>
            </html>`;

          iframe.srcdoc = html;
          setLastRenderedCode(code);
          setHasChanges(false);
        }, [code]);

        return (
          <div className="preview-container">
            <iframe ref={iframeRef} title="Preview" sandbox="allow-scripts" />
            <button 
              className="preview-rerun-button" 
              onClick={renderPreview}
              disabled={!hasChanges}
            >
              {hasChanges ? "Re-run" : "Up to date"}
            </button>
          </div>
        );
      }

      // CodeEditor Component
      function CodeEditor({ code, onChange }) {
        const editorRef = useRef(null);
        const cmRef = useRef(null);
        const isInternalChange = useRef(false);
        const callbackRef = useRef({ onChange });
        const { isDarkMode } = useTheme();

        // Keep the callback ref updated
        useEffect(() => {
          callbackRef.current = { onChange };
        }, [onChange]);

        // Initialize CodeMirror
        useEffect(() => {
          if (!editorRef.current) return;
          
          cmRef.current = CodeMirror(editorRef.current, {
            value: code,
            mode: "jsx",
            lineNumbers: true,
            theme: isDarkMode ? "dracula" : "default",
            autoCloseBrackets: true,
            matchBrackets: true,
            tabSize: 2,
            indentWithTabs: false,
            lineWrapping: true
          });
          
          cmRef.current.on("change", (instance) => {
            if (!isInternalChange.current) {
              callbackRef.current.onChange(instance.getValue());
            }
          });

          return () => {
            if (cmRef.current) {
              cmRef.current.toTextArea();
            }
          };
        }, []);

        // Update code when prop changes
        useEffect(() => {
          if (cmRef.current && cmRef.current.getValue() !== code) {
            isInternalChange.current = true;
            cmRef.current.setValue(code);
            isInternalChange.current = false;
          }
        }, [code]);
        
        // Update theme when darkMode changes
        useEffect(() => {
          if (cmRef.current) {
            cmRef.current.setOption('theme', isDarkMode ? 'dracula' : 'default');
          }
        }, [isDarkMode]);

        return <div style={{ flex: 1 }} ref={editorRef}></div>;
      }

      // Main IDE Component
      function IDEPage() {
        const { 
          currentChallengeId, 
          challengeCodes, 
          updateChallengeCode, 
          markChallengeCompleted,
          challenges 
        } = useChallenges();
        const [isPreviewOpen, setIsPreviewOpen] = useState(false);
        const [vibeStatus, setVibeStatus] = useState("idle");
        const { isConfigured } = useAI();
        const toast = useToast();
        const currentCode = challengeCodes[currentChallengeId];

        const handleCodeChange = useCallback(newCode => {
          updateChallengeCode(currentChallengeId, newCode);
        }, [currentChallengeId, updateChallengeCode]);

        const handleSubmit = async () => {
          const result = await runTests(currentChallengeId, currentCode);
          if (result.success) {
            markChallengeCompleted(currentChallengeId);
            setVibeStatus("success");
            alert("All tests passed! Vibe challenge completed.");
          } else {
            setVibeStatus("fail");
            alert("Some tests failed. Check your code and try again to keep the vibes high.");
          }
        };

        return (
          <div style={{
            height: "100vh",
            display: "flex",
            flexDirection: "column",
          }}>
            <Header vibeStatus={vibeStatus} />
            <div className="app-container">
              <Sidebar />
              <div className="main-content">
                <div className="editor-container">
                  <CodeEditor code={currentCode} onChange={handleCodeChange} />
                </div>
              </div>
            </div>
            <div className="sidebar-right">
              <div className="fab-container">
                <button 
                  className="fab-button fab-preview" 
                  onClick={() => setIsPreviewOpen(!isPreviewOpen)}
                  title={isPreviewOpen ? "Hide Preview" : "Show Preview"}
                >
                  {isPreviewOpen ? <Icons.HidePreview /> : <Icons.Preview />}
                </button>
                <button 
                  className="fab-button fab-run" 
                  onClick={handleSubmit}
                  title="Run Tests"
                >
                  <Icons.Run />
                </button>
                <ProcessTodoButton />
                <button 
                  className="fab-button fab-reset" 
                  onClick={() => {
                    const challenge = challenges.find(c => c.id === currentChallengeId);
                    if (challenge && window.confirm("Reset code to default state? This cannot be undone.")) {
                      updateChallengeCode(currentChallengeId, challenge.starterCode);
                      toast.addToast("Code reset to default state", "success");
                    }
                  }}
                  title="Reset to Default"
                >
                  <Icons.Reset />
                </button>
              </div>
            </div>
            <div className={`preview-drawer ${isPreviewOpen ? "open" : ""}`}>
              <Preview />
            </div>
            <button className="fab-button fab-new-vibe" title="New Vibe (coming soon)">
              <Icons.NewVibe />
            </button>
          </div>
        );
      }

      // Root App Component wrapping all providers
      function App() {
        return (
          <ThemeProvider>
            <ChallengeProvider initialChallenges={initialChallengesData}>
              <AIProvider>
                <ToastProvider>
                  <IDEPage />
                </ToastProvider>
              </AIProvider>
            </ChallengeProvider>
          </ThemeProvider>
        );
      }

      // Render the application
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
    </script>
  </body>
</html>
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleExpand(challenge.id);
                }}
              >
                <Icons.ChevronRight />
              </div>
            </div>
            <div className={`challenge-content ${isExpanded ? 'open' : ''}`}>
              <div className="challenge-description">{challenge.description}</div>
            </div>
          </div>
        );
      }

      // Sidebar Component
      function Sidebar() {
        const { challenges, currentChallengeId, selectChallenge } = useChallenges();
        const [expandedId, setExpandedId] = useState(currentChallengeId);
        
        // Automatically expand the selected challenge
        useEffect(() => {
          setExpandedId(currentChallengeId);
        }, [currentChallengeId]);
        
        const handleToggleExpand = (id) => {
          setExpandedId(expandedId === id ? null : id);
        };
        
        return (
          <div className="sidebar">
            <div className="sidebar-header">
              <span>Challenges</span>
            </div>
            <div className="challenges-list">
              {challenges.map((challenge) => (
                <ChallengeItem
                  key={challenge.id}
                  challenge={challenge}
                  isSelected={challenge.id === currentChallengeId}
                  onSelect={selectChallenge}
                  isExpanded={expandedId === challenge.id}
                  onToggleExpand={handleToggleExpand}
                />
              ))}
            </div>
          </div>
        );
      }

      // Preview Component
      function Preview() {
        const { currentChallengeId, challengeCodes } = useChallenges();
        const code = challengeCodes[currentChallengeId] || '';
        const iframeRef = useRef(null);
        const [hasChanges, setHasChanges] = useState(false);
        const [lastRenderedCode, setLastRenderedCode] = useState(code);
        const isDrawerOpen = useRef(false); // Ref to track drawer state

        // Get drawer open state from parent component
        useEffect(() => {
          const drawer = document.querySelector('.preview-drawer');
          if (drawer) {
            const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                if (mutation.attributeName === 'class') {
                  isDrawerOpen.current = drawer.classList.contains('open');
                  // If drawer just opened and there are changes, render preview
                  if (isDrawerOpen.current && hasChanges) {
                    renderPreview();
                  }
                }
              });
            });
            
            observer.observe(drawer, { attributes: true });
            isDrawerOpen.current = drawer.classList.contains('open');
            
            return () => observer.disconnect();
          }
        }, [hasChanges]);

        // Reset lastRenderedCode when challenge changes
        useEffect(() => {
          setLastRenderedCode(""); // Reset on challenge change
          setHasChanges(true);
          
          // Only render immediately if drawer is open
          if (isDrawerOpen.current) {
            renderPreview();
          }
        }, [currentChallengeId]);

        useEffect(() => {
          if (code !== lastRenderedCode) {
            setHasChanges(true);
            
            // Only auto-update if drawer is open
            if (isDrawerOpen.current) {
              renderPreview();
            }
          }
        }, [code, lastRenderedCode]);

        const renderPreview = useCallback(() => {
          const iframe = iframeRef.current;
          if (!iframe) return;

          // Determine if the code contains React/JSX syntax
          const isReactComponent =
            code.includes("function") &&
            code.includes("return") &&
            code.includes("<");

          // make sure to avoid writing <script> directly here
          // use string literal instead, e.g. ${script}
          const script = "script";

          const html = `
            <!DOCTYPE html>
            <html>
              <head>
                <${script} type="importmap">
                  {
                    "imports": {
                      "react": "https://ga.jspm.io/npm:react@18.3.1/index.js",
                      "react-dom": "https://ga.jspm.io/npm:react-dom@18.3.1/index.js"
                    },
                    "scopes": {
                      "https://ga.jspm.io/": {
                        "scheduler": "https://ga.jspm.io/npm:scheduler@0.23.2/index.js"
                      }
                    }
                  }
                </${script}>
                <${script} async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></${script}>
                <${script} src="https://unpkg.com/@babel/standalone/babel.min.js"></${script}>
                <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
                <style>
                  :root {
                    --blue-500: #3182ce;
                    --blue-600: #2b6cb0;
                    --gray-100: #f7fafc;
                    --gray-200: #edf2f7;
                    --gray-700: #4a5568;
                    --gray-900: #1a202c;
                    --red-500: #f56565;
                    --green-500: #48bb78;
                  }
                  
                  * {
                    box-sizing: border-box;
                  }
                  
                  body {
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    padding: 24px;
                    line-height: 1.5;
                    color: var(--gray-900);
                    font-size: 16px;
                    margin: 0;
                  }
                  
                  .dark-mode {
                    background-color: var(--gray-900);
                    color: var(--gray-100);
                  }

                  h1, h2, h3, h4, h5 {
                    margin-top: 0;
                    line-height: 1.2;
                  }
                  
                  button {
                    margin: 0 6px;
                    padding: 6px 12px;
                    background: var(--blue-500);
                    color: white;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-family: inherit;
                    font-size: 14px;
                    font-weight: 500;
                  }
                  
                  button:hover {
                    background: var(--blue-600);
                  }
                  
                  pre {
                    background: var(--gray-100);
                    padding: 16px;
                    border-radius: 8px;
                    overflow: auto;
                    font-size: 14px;
                    border: 1px solid var(--gray-200);
                  }
                  
                  .error {
                    color: var(--red-500);
                    padding: 12px;
                    border-radius: 6px;
                    background-color: rgba(245, 101, 101, 0.1);
                    margin: 16px 0;
                  }
                  
                  .success {
                    color: var(--green-500);
                    padding: 12px;
                    border-radius: 6px;
                    background-color: rgba(72, 187, 120, 0.1);
                    margin: 16px 0;
                  }
                  
                  @media (prefers-color-scheme: dark) {
                    body {
                      background-color: var(--gray-900);
                      color: var(--gray-100);
                    }
                    pre {
                      background: rgba(255, 255, 255, 0.1);
                      border-color: rgba(255, 255, 255, 0.2);
                    }
                  }
                </style>
              </head>
              <body>
                <div id="root"></div>
                <${script} type="text/babel" data-presets="react" data-type="module">
                  import React from 'react';
                  import ReactDOM from 'react-dom';

                  ${code}
                  ${
                    isReactComponent
                      ? `
                    // Extract the component name from the code
                    const match = ${JSON.stringify(
                      code
                    )}.match(/function\\s+(\\w+)/);
                    if (match) {
                      const ComponentName = eval(match[1]);
                      ReactDOM.render(React.createElement(ComponentName), document.getElementById('root'));
                    }
                  `
                      : `
                    // For non-React challenges, show the function result
                    const match = ${JSON.stringify(
                      code
                    )}.match(/function\\s+(\\w+)/);
                    if (match) {
                      const funcName = match[1];
                      const func = eval('(' + ${JSON.stringify(code)} + ')');
                      document.getElementById('root').innerHTML = '<h3>Function: ' + funcName + '</h3>' +
                        '<p>Try calling this function in the browser console!</p>' +
                        '<div class="success">✓ Function defined successfully</div>';
                      window[funcName] = func;
                      console.log("✓ Function " + funcName + " is available in the console.");
                    }
                  `
                  }
                </${script}>
              </body>
            </html>`;

          iframe.srcdoc = html;
          setLastRenderedCode(code);
          setHasChanges(false);
        }, [code]);

        return (
          <div className="preview-container">
            <iframe ref={iframeRef} title="Preview" sandbox="allow-scripts" />
            <button 
              className="preview-rerun-button" 
              onClick={renderPreview}
              disabled={!hasChanges}
            >
              {hasChanges ? "Re-run" : "Up to date"}
            </button>
          </div>
        );
      }

      // CodeEditor Component
      function CodeEditor({ code, onChange }) {
        const editorRef = useRef(null);
        const cmRef = useRef(null);
        const isInternalChange = useRef(false);
        const callbackRef = useRef({ onChange });
        const { isDarkMode } = useTheme();

        // Keep the callback ref updated
        useEffect(() => {
          callbackRef.current = { onChange };
        }, [onChange]);

        // Initialize CodeMirror
        useEffect(() => {
          if (!editorRef.current) return;
          
          cmRef.current = CodeMirror(editorRef.current, {
            value: code,
            mode: "jsx",
            lineNumbers: true,
            theme: isDarkMode ? "dracula" : "default",
            autoCloseBrackets: true,
            matchBrackets: true,
            tabSize: 2,
            indentWithTabs: false,
            lineWrapping: true
          });
          
          cmRef.current.on("change", (instance) => {
            if (!isInternalChange.current) {
              callbackRef.current.onChange(instance.getValue());
            }
          });

          return () => {
            if (cmRef.current) {
              cmRef.current.toTextArea();
            }
          };
        }, []);

        // Update code when prop changes
        useEffect(() => {
          if (cmRef.current && cmRef.current.getValue() !== code) {
            isInternalChange.current = true;
            cmRef.current.setValue(code);
            isInternalChange.current = false;
          }
        }, [code]);
        
        // Update theme when darkMode changes
        useEffect(() => {
          if (cmRef.current) {
            cmRef.current.setOption('theme', isDarkMode ? 'dracula' : 'default');
          }
        }, [isDarkMode]);

        return <div style={{ flex: 1 }} ref={editorRef}></div>;
      }

      // Main IDE Component
      function IDEPage() {
        const { 
          currentChallengeId, 
          challengeCodes, 
          updateChallengeCode, 
          markChallengeCompleted,
          challenges 
        } = useChallenges();
        const [isPreviewOpen, setIsPreviewOpen] = useState(false);
        const { isConfigured } = useAI();
        const toast = useToast();
        
        // Get current code based on selected challenge
        const currentCode = challengeCodes[currentChallengeId];
        
        const handleCodeChange = useCallback(newCode => {
          updateChallengeCode(currentChallengeId, newCode);
        }, [currentChallengeId, updateChallengeCode]);

        const handleSubmit = async () => {
          const result = await runTests(currentChallengeId, currentCode);
          
          if (result.success) {
            markChallengeCompleted(currentChallengeId);
            alert("All tests passed! Vibe challenge completed.");
          } else {
            alert("Some tests failed. Check your code and try again to keep the vibes high.");
          }
        };

        return (
          <div
            style={{
              height: "100vh",
              display: "flex",
              flexDirection: "column",
            }}
          >
            <Header />
            <div className="app-container">
              <Sidebar />
              <div className="main-content">
                <div className="editor-container">
                  <CodeEditor code={currentCode} onChange={handleCodeChange} />
                </div>
              </div>
            </div>
            
            {/* Fixed positioned elements outside the normal flow */}
            <div className="sidebar-right">
              <div className="fab-container">
                {/* Preview and Run buttons moved to the top */}
                <button 
                  className="fab-button fab-preview" 
                  onClick={() => setIsPreviewOpen(!isPreviewOpen)}
                  title={isPreviewOpen ? "Hide Preview" : "Show Preview"}
                >
                  {isPreviewOpen ? <Icons.HidePreview /> : <Icons.Preview />}
                </button>
                <button 
                  className="fab-button fab-run" 
                  onClick={handleSubmit}
                  title="Run Tests"
                >
                  <Icons.Run />
                </button>

                <ProcessTodoButton />
                
                <button 
                  className="fab-button fab-reset" 
                  onClick={() => {
                    const challenge = challenges.find(c => c.id === currentChallengeId);
                    if (challenge && window.confirm("Reset code to default state? This cannot be undone.")) {
                      updateChallengeCode(currentChallengeId, challenge.starterCode);
                      toast.addToast("Code reset to default state", "success");
                    }
                  }}
                  title="Reset to Default"
                >
                  <Icons.Reset />
                </button>
              </div>
            </div>
            
            <div
              className={`preview-drawer ${isPreviewOpen ? "open" : ""}`}
            >
              <Preview />
            </div>
          </div>
        );
      }

      // Root App Component wrapping all providers
      function App() {
        return (
          <ThemeProvider>
            <ChallengeProvider initialChallenges={initialChallengesData}>
              <AIProvider>
                <ToastProvider>
                  <IDEPage />
                </ToastProvider>
              </AIProvider>
            </ChallengeProvider>
          </ThemeProvider>
        );
      }

      // Render the application
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html>
